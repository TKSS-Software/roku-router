import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "interfaces.bs"
import "RouterState.bs"

'************************
'*** This namespace can be used inside any component that is a view, or child of a view
'*** DO NOT USE THIS FILE OUTSIDE OF A VIEW COMPONENT, such as the main scene
'************************
namespace rokuRouter

    function initialize(params = {} as Object) as Dynamic
        routerObject = Invalid
        if params.router = Invalid then
            routerObject = createObject("roSGNode", "Router")
        else
            routerObject = params.router
        end if

        if params.outlet = Invalid then
            params.outlet = rokuRouter.searchForOutlet(m.top.getScene())
        end if

        ' Validate the outlet
        if rodash.isNode(routerObject) AND routerObject.hasField("__isRouter") AND rodash.isNode(params.outlet) AND params.outlet.hasField("__isOutlet") then
            m.top.getScene().addFields({ __router: routerObject })
            return routerObject@._initialize(params)
        end if

        return Invalid
    end function

    ' This function is used to navigate to a different screen
    ' It will return a promise that will resolve when the navigation is complete
    ' @since 0.0.1
    ' @param path - The path to navigate to
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    ' @return - A promise that will resolve when the navigation is complete
    function navigateTo(path = "" as String, options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._navigateTo(path, options)
        end if
        return promises.resolve(true)
    end function

    function goBack(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._goBack(Invalid)
        end if
        return false
    end function

    ' This function is used to add routes to the router
    ' @since 0.0.1
    ' @param routes - The routes to add
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    sub addRoutes(routes = [] as Object, options = {} as Object)
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            r@._addRoutes(routes)
        end if
    end sub

    ' This function is used to get all routes from the router
    ' @since 0.0.1
    ' @return - All routes from the router
    function getRoutes(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._getRoutes()
        end if
        return {}
    end function

    ' Gets the router from the global scope. Creates the router if it does not exist.
    ' @since 0.0.1
    ' @return - The router
    function getRouter() as Dynamic
        return m.top.getScene().__router
    end function

    function searchForOutlet(parent = Invalid as Dynamic, depth = 0 as Integer) as Dynamic
        ' Stop if too deep
        if depth > 30 then
            return Invalid
        end if

        if parent = Invalid then
            parent = m.top
        end if

        outlet = Invalid

        'Look top level
        for each node in rodash.getNodeChildren(parent)
            if rodash.isNode(node) AND node.hasField("__isOutlet") then
                outlet = node
            else
                outlet = searchForOutlet(node, depth + 1)
            end if

            if outlet <> Invalid then
                return outlet
            end if
        end for

        return Invalid
    end function

    function setFocus(options = {} as Object) as Boolean
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) AND rodash.isBoolean(options.focus) then
            return r@._setFocus(options.focus)
        end if
        return false
    end function

    ' This function is used to create a redirect command
    ' Redirect commands are used to redirect the user to a different screen during a guard check
    ' @since 0.0.1
    ' @param path - The path to redirect to
    ' @param routeConfigOverrides - The route config overrides to apply to the new route
    ' @param context - The context to pass to the router
    ' @return - A redirect command
    function createRedirectCommand(path = "" as String, routeConfigOverrides = {} as Object, context = {} as Object) as Dynamic
        return {
            command: "RedirectCommand"
            path: path
            routeConfigOverrides: routeConfigOverrides
            context: context
        }
    end function

end namespace

namespace rokuRouter.utils
    ' This function is used to get the current focused chain of nodes
    ' @since 0.0.1
    ' @param parent - The parent node to start the search from
    ' @param maxDepth - The maximum depth to search
    ' @return - The chain of nodes
    function getCurrentFocusedChain(parent = Invalid as Object, maxDepth = 30 as Integer) as Object
        if rodash.isNode(parent) then
            targetNode = parent
        else
            targetNode = m.top.getScene()
        end if

        focusedChild = targetNode.focusedChild

        chain = [targetNode]

        if rodash.isNode(focusedChild) then
            while maxDepth > 0 AND NOT rodash.isEqual(focusedChild, targetNode)
                targetNode = focusedChild

                ' There is a chance the chain is incomplete
                if targetNode = Invalid then exit while
                chain.push(targetNode)
                focusedChild = targetNode.focusedChild 'bs:disable-line LINT1005
                maxDepth--
            end while

            return chain
        end if

        return chain
    end function
end namespace
