import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "pkg:/source/router.bs"

' Initialize the router
sub init()
    m.top.focusRequestMade = false
    m.__router_guardInstances = {}
    m.__router_outlet = Invalid
    m.__router_routes = {}

    m.top.focusable = true
end sub


'*************************************************************************
'#region *** PUBLIC Functions
'*************************************************************************

function _initialize(params = {} as Object) as Dynamic
    m.__router_outlet = params.outlet

    if m.__router_outlet <> Invalid then
        m.__router_outlet.unobserveField("focusedChild")
        m.__router_outlet.observeField("focusedChild", "onFocusChildChanged")
    end if

    return m.top
end function

' Function to add routes to the router' @param {Array} routes - The routes to add
sub _addRoutes(routes = [] as Object)
    routeStructure = {
        pattern: ""
        component: ""
        allowReuse: false
        canActivate: []
        isRoot: false
        keepRootAlive: false
        isDialog: false
        isChild: false
        children: []
        parent: ""
    }


    for each route in routes
        pattern = rokuRouter.utils.normalizePath(route.pattern)
        m.__router_routes[pattern] = rodash.merge({}, [routeStructure, route, {
                pattern: rokuRouter.utils.normalizePath(pattern)
        }])

        if rodash.isNonEmptyArray(route.children) then
            children = []
            for each child in route.children
                childPattern = pattern + rokuRouter.utils.normalizePath(child.pattern)
                m.__router_routes[childPattern] = rodash.merge({}, [routeStructure, child, {
                        pattern: childPattern
                        parent: route.pattern
                        isChild: true
                        isRoot: rodash.get(m.__router_routes[pattern], "isRoot")
                        children: [] ' Currently, we don't support children of children
                }])
                children.push(childPattern)
            end for
            route.children = children
        end if
    end for
end sub

' Function to get the routes' @returns {Array} - The routes
function _getRoutes(_ = Invalid as Dynamic) as Dynamic
    return m.__router_routes
end function

' Function to navigate back in the router history' @returns {Boolean} - Whether the navigation was successful or not


' Function to navigate to a specific route
' @param {String} path - The path to navigate to
' @param {Object} options - The route config overrides
' @returns {Dynamic} - The result of the navigation
function _navigateTo(path = "" as String, options = {}) as Dynamic
    routeConfigOverrides = rodash.getAA(options, "routeConfigOverrides")
    navigationState = rodash.getAA(options, "navigationState")
    context = rodash.getAA(options, "context")

    newRoute = rodash.createNode("Node", rokuRouter.utils.findMatchingRoute(path, m.__router_routes))

    ' An event triggered when a navigation starts.
    rokuRouter.utils.dispatchRouterState(RouterState.NavigationStart, {
        id: newRoute.id
    })

    if m.__router_outlet = Invalid then
        message = { message: `No Outlet found` }

        ' An event triggered when a navigation error occurs.
        rokuRouter.utils.dispatchRouterState(RouterState.NavigationError, {
            id: newRoute.id
            error: message
            route: newRoute
        })
    end if

    if NOT rodash.isNonEmptyString(newRoute.routeConfig.pattern) then
        message = { message: `Route "${newRoute.path}" not found` }

        ' An event triggered when a navigation error occurs.
        rokuRouter.utils.dispatchRouterState(RouterState.NavigationError, {
            id: newRoute.id
            error: message
            route: newRoute
        })

        return promises.reject(message)
    end if

    'An event triggered when routes are recognized.
    rokuRouter.utils.dispatchRouterState(RouterState.RoutesRecognized, {
        id: newRoute.id
        route: newRoute
    })

    ' Merge the context
    if rodash.isNonEmptyAA(context) then
        newRouteContext = rodash.merge(newRoute.context, context)
        newRoute.context = newRouteContext
    end if

    ' Merge the route config overrides
    if rodash.isNonEmptyAA(routeConfigOverrides) then
        newRouteConfig = rodash.merge(newRoute.routeConfig, routeConfigOverrides)
        newRoute.routeConfig = newRouteConfig
    end if

    ' Merge the navigation state
    if rodash.isNonEmptyAA(navigationState) then
        newRouteNavigationState = rodash.merge(newRoute.navigationState, navigationState)
        newRoute.navigationState = newRouteNavigationState
    end if


    'sleep until next tick, then continue work
    return promises.chain(promises.resolve(true), { newRoute: newRoute }).then(function(_ as Dynamic, internalContext as Dynamic) as Dynamic
        return runGuardChecks(internalContext.newRoute)
    end function).then(function(guardCheckResponse as Dynamic, internalContext as Dynamic) as Dynamic
        if NOT guardCheckResponse.allow then
            if guardCheckResponse.redirect <> Invalid then
                return guardCheckResponse.redirect
            end if

            promises.reject(guardCheckResponse)
        end if

        newRoute = internalContext.newRoute

        m.top.processingRouteUpdate = false
        return m.__router_outlet@._processNavigation(newRoute)
    end function).toPromise()
end function

function _goBack(_ = Invalid as Dynamic) as Dynamic
    if m.__router_outlet <> Invalid then
        return m.__router_outlet@.goBack()
    end if

    return false
end function

' A public function to set the focus on the router' @param {Boolean} takeFocus - Whether to take focus or not
' @returns {Boolean} - Whether the active view handled the focus or not
function _setFocus(takeFocus as Boolean) as Boolean
    response = false

    if m.__router_outlet.activeView <> Invalid AND takeFocus AND m.top.focusRequestMade <> takeFocus then
        response = m.__router_outlet@._handleFocus({
            routerFocused: true
        })
    end if
    m.top.focusRequestMade = true
    return response
end function

'*************************************************************************
'#endregion *** PUBLIC Functions
'*************************************************************************


'*************************************************************************
'#region *** PRIVATE Guard Functions
'*************************************************************************

' Function to run guard checks' @param {Dynamic} route - The route to run the guard checks on
' @returns {Dynamic} - The result of the guard checks
function runGuardChecks(route as Dynamic) as Dynamic
    ' Run guard checks
    canActivateGuard = rodash.get(route.routeConfig, "canActivate")
    rokuRouter.utils.dispatchRouterState(RouterState.GuardsCheckStart, {
        id: route.id
        route: route
    })
    if rodash.isNonEmptyArray(canActivateGuard) then
        for each guard in canActivateGuard
            guardNode = Invalid
            if rodash.isNode(guard) then
                guardNode = guard
            else if rodash.isString(guard) then
                if m.__router_guardInstances[guard] = Invalid then
                    m.__router_guardInstances[guard] = rodash.createNode(guard)
                end if

                guardNode = m.__router_guardInstances[guard]
            end if

            if guardNode <> Invalid then
                canActivateResult = guardNode@.canActivate(route)

                if rodash.isBoolean(canActivateResult) then
                    canActivate = canActivateResult

                    if NOT canActivate then
                        message = { allow: false, message: `Route "${route.path}" is not accessible` }
                        rokuRouter.utils.dispatchRouterState(RouterState.GuardsCheckEnd, {
                            id: route.id
                            route: route
                        })
                        return promises.resolve(message)
                    end if
                else if rodash.isNonEmptyAA(canActivateResult) then
                    redirectTo = rodash.getString(canActivateResult, "path")
                    if rodash.isNonEmptyString(redirectTo) then
                        ' An event triggered at the end of the Guard phase of routing.
                        rokuRouter.utils.dispatchRouterState(RouterState.GuardsCheckEnd, {
                            id: route.id
                            route: route
                        })

                        ' An event triggered when a navigation is canceled, directly or indirectly. This can happen for several reasons including when a route guard returns false or initiates a redirect.
                        rokuRouter.utils.dispatchRouterState(RouterState.NavigationCancel, {
                            id: route.id
                            route: route
                        })

                        ' Options to merge
                        toMerge = []
                        if rodash.isNonEmptyAA(route.options) then
                            toMerge.push(route.options)
                        end if
                        if rodash.isNonEmptyAA(canActivateResult.options) then
                            toMerge.push(canActivateResult.options)
                        end if
                        toMerge.push({ navigationState: { fromRedirect: true } })

                        options = rodash.merge({}, toMerge)
                        return promises.resolve({ allow: false, redirect: _navigateTo(redirectTo, options) })
                    end if
                else
                    message = { allow: false, message: `Invalid Route Guard on "${route.path}"` }
                    return promises.resolve(message)
                end if
            end if
        end for
    end if

    ' An event triggered at the start of the activation part of the Resolve phase of routing.
    rokuRouter.utils.dispatchRouterState(RouterState.ActivationStart, {
        id: route.id
        route: route
    })

    ' An event triggered at the end of the Guard phase of routing.
    rokuRouter.utils.dispatchRouterState(RouterState.GuardsCheckEnd, {
        id: route.id
        route: route
    })
    return promises.resolve({ allow: true })
end function

'*************************************************************************
'#endregion *** PRIVATE Guard Functions
'*************************************************************************


'*************************************************************************
'#region *** PRIVATE View Stack Management Functions
'*************************************************************************

' Called when the focus chain of the router changes' @param {Object} event - The event object
sub onFocusChildChanged(event as Object)
    inFocusChain = event.getData() <> Invalid

    if m.top.processingGoBack AND m.__router_outlet.activeView <> Invalid AND NOT inFocusChain AND m.top.focusRequestMade <> inFocusChain then
        m.__router_outlet@._handleFocus({
            routerFocused: inFocusChain
        })
    end if

    m.top.focusRequestMade = inFocusChain
end sub

'*************************************************************************
'#endregion *** PRIVATE View Stack Management Functions
'*************************************************************************









