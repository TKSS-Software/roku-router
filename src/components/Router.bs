import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "pkg:/source/router.bs"

sub init()
    m.top.focusable = true
    m.top.observeField("focusedChild", "onFocusChildChanged")

    m.activeScreen = Invalid
    m.routes = {}
    m.guardInstances = {}

    m.focusRequestMade = false
    m.processingGoBack = false

    m.top.appLaunchComplete = false
end sub

sub onFocusChildChanged(event as Object)
    inFocusChain = event.getData() <> Invalid

    if NOT m.processingGoBack AND m.activeScreen <> Invalid AND NOT inFocusChain AND m.focusRequestMade <> inFocusChain then
        m.focusRequestMade = inFocusChain
        m.activeScreen@._handleFocus({
            routerFocused: inFocusChain
        })
    end if

    m.focusRequestMade = inFocusChain
end sub

function setFocus(takeFocus as Boolean) as Boolean
    print source_function_name, takeFocus
    response = false

    if m.activeScreen <> Invalid AND takeFocus AND m.focusRequestMade <> takeFocus then
        response = m.activeScreen@._handleFocus({
            routerFocused: true
        })
    end if

    m.focusRequestMade = true

    return response
end function

sub addRoutes(routes = [] as Object)
    for each route in routes
        m.routes[route.pattern] = route
    end for
end sub

' Function to get the routes
function getRoutes(_ = Invalid as Dynamic) as Dynamic
    return m.routes
end function

' Function to navigate back in the router history
function goBack(_ = Invalid as Dynamic) as Dynamic
    m.processingGoBack = true
    screens = rodash.getNodeChildren(m.viewTarget)
    numberOfScreens = screens.count()
    if numberOfScreens <= 1 then return false

    promises.chain(closeScreen(screens.pop()), screens.peek()).then(sub(response as Dynamic, screen as Dynamic)
        m.focusRequestMade = m.focusRequestMade OR m.processingGoBack
        showScreen(screen, true)
    end sub)

    return true
end function

function dispatchRouterState(stateType as String, context = {} as Dynamic) as Dynamic
    update = {
        type: stateType
        id: rodash.getString(context, "route.id", context.id)
        route: rodash.get(context, "route")
    }

    if stateType = RouterStates.GuardResult then
        update.result = rodash.get(context, "result")
    end if
    m.top.routerState = update
    return promises.resolve(update)
end function

' Function to navigate to a specific route
function navigateTo(path = "" as String, options = {} as Object, context = {} as Object) as Dynamic
    id = CreateObject("roDeviceInfo").GetRandomUUID()
    matchedRoute = findMatchingRoute(path, m.routes, id)

    dispatchRouterState(RouterStates.NavigationStart, {
        id: id
        route: matchedRoute
    })

    if rodash.isNonEmptyAA(matchedRoute.routeConfig) then
        ' Run guard checks
        canActivateGuard = rodash.get(matchedRoute.routeConfig, "canActivate")
        dispatchRouterState(RouterStates.GuardsCheckStart, {
            id: id
            route: matchedRoute
        })
        if rodash.isNonEmptyArray(canActivateGuard) then
            for each guard in canActivateGuard
                guardNode = Invalid
                if rodash.isNode(guard) then
                    guardNode = guard
                else if rodash.isString(guard) then
                    if m.guardInstances[guard] = Invalid then
                        m.guardInstances[guard] = rodash.createNode(guard)
                    end if

                    guardNode = m.guardInstances[guard]
                end if

                if guardNode <> Invalid then
                    canActivateResult = guardNode@.canActivate(matchedRoute)
                    print "canActivateResult", canActivateResult
                    dispatchRouterState(RouterStates.GuardResult, {
                        id: id
                        route: matchedRoute
                        type: "canActivate"
                        result: canActivateResult
                    })

                    if rodash.isBoolean(canActivateResult) then
                        canActivate = canActivateResult

                        if NOT canActivate then
                            message = { message: `Route "${path}" is not accessible` }
                            print message
                            dispatchRouterState(RouterStates.GuardsCheckEnd, {
                                id: id
                                route: matchedRoute
                            })
                            return promises.reject(message)
                        end if
                    else if rodash.isNonEmptyAA(canActivateResult) then
                        redirectTo = rodash.getString(canActivateResult, "path")
                        if rodash.isNonEmptyString(redirectTo) then
                            dispatchRouterState(RouterStates.GuardsCheckEnd, {
                                id: id
                                route: matchedRoute
                            })
                            dispatchRouterState(RouterStates.NavigationCancel, {
                                id: id
                                route: matchedRoute
                            })
                            return navigateTo(redirectTo, rodash.getAA(canActivateResult, "options"), rodash.getAA(canActivateResult, "context"))
                        end if
                    else
                        return promises.reject(message)
                    end if
                end if
            end for
        end if

        dispatchRouterState(RouterStates.GuardsCheckEnd, {
            id: id
            route: matchedRoute
        })

        if rodash.isEmptyString(rodash.getString(matchedRoute, "routeConfig.component")) then
            return promises.reject({ message: `No component for route "${path}"` })
        end if

        newRoute = {
            context: context
        }
        newRoute.append(matchedRoute)

        viewsToRemove = []
        if m.activeScreen <> Invalid then
            oldRoute = m.activeScreen.route

            ' Reuse the screen and call onRouteUpdate if the path or hash is the same, OR if the options allow it
            hasHash = rodash.isNonEmptyString(newRoute.hash)
            isSamePath = rodash.isEqual(newRoute.path, oldRoute.path)
            reuse = rodash.getBoolean(options, "allowReuse") OR hasHash OR isSamePath
            if hasHash then
                if NOT rodash.isEqual(newRoute.routeConfig, oldRoute.routeConfig) then reuse = false
            else
                if NOT rodash.isEqual(newRoute.routeParams.component, oldRoute.routeParams.component) then reuse = false
            end if

            if reuse then
                m.activeScreen.route = newRoute
                m.activeScreen@._onRouteUpdate({
                    oldRoute: oldRoute
                    newRoute: newRoute
                })
                dispatchRouterState(RouterStates.NavigationEnd, {
                    id: id
                    route: newRoute
                })
                return promises.resolve(m.activeScreen)
            else
                if newRoute.routeConfig.isRoot then
                    for each screen in rodash.getNodeChildren(m.viewTarget)
                        viewsToRemove.push(screen)
                    end for
                end if
            end if
        end if
        return addViewToStack(newRoute, viewsToRemove)
    end if

    dispatchRouterState(RouterStates.NavigationError, {
        id: id
    })
    message = { message: `Route "${path}" not found` }
    print message
    return promises.reject(message)
end function

function addViewToStack(route as Dynamic, closeViews = [] as Object) as Dynamic
    componentName = rodash.getString(route, "routeConfig.component")
    screen = rodash.createNode(componentName)
    if screen = Invalid then
        return promises.reject({ message: `Failed to create screen "${componentName}"` })
    end if

    screen.id = route.id
    screen.route = route
    screen.router = m.top
    return promises.chain(screen@._beforeScreenOpen(route), { screen: screen, closeViews: closeViews }).then(function(response as Dynamic, context as Dynamic) as Dynamic
        m.viewTarget.appendChild(context.screen)
        hideScreen(m.activeScreen)

        promisesToResolve = []
        if rodash.isNonEmptyArray(context.closeViews) then
            for each view in context.closeViews
                promisesToResolve.push(view@._beforeScreenClose(context.screen.route))
            end for
        end if

        return promises.chain(promises.all(promisesToResolve), context).then(function(_ as Dynamic, context as Dynamic) as Dynamic
            return promises.chain(showScreen(context.screen), context).then(function(response as Dynamic, context as Dynamic) as Dynamic
                if rodash.isNonEmptyArray(context.closeViews) then
                    for each view in context.closeViews
                        if hideScreen(view) then rodash.removeNode(view)
                    end for
                end if
                return response
            end function).toPromise()
        end function)
    end function).catch(function(error as Dynamic) as Dynamic
        return promises.reject(error)
    end function).toPromise()
end function


' Helper function to find a matching route
function findMatchingRoute(path as String, routes as Object, id as String) as RouteObject
    hash = Router._utils.getHashParam(path)

    if rodash.isNonEmptyString(hash) then
        path = path.replace("#" + hash, "")
    end if

    ' Separate the path from the query string
    pathParts = path.split("?")
    basePath = normalizePath(pathParts[0])
    queryString = Invalid
    if pathParts.count() > 1 then
        queryString = pathParts[1]
    end if

    ' Parse the query string if present
    queryParams = parseQueryString(queryString)

    ' First check for exact matches (static paths)
    for each routePath in routes
        if normalizePath(routePath) = basePath then
            routeConfig = routes[routePath]
            ' Backfill routeConfig with default values
            routeConfig.canActivate = rodash.getArray(routeConfig, "canActivate")
            routeConfig.isRoot = rodash.getBoolean(routeConfig, "isRoot")
            routeConfig.isDialog = rodash.getBoolean(routeConfig, "isDialog")

            return {
                path: path
                routeConfig: routeConfig
                routeParams: {}
                queryParams: queryParams
                hash: hash
                id: id
                router: m.top
            }
        end if
    end for

    ' Then check parameterized matches
    for each routePath in routes
        routeParts = normalizePath(routePath).split("/")
        pathParts = basePath.split("/")

        matchedParams = {}
        if routeParts.count() = pathParts.count() then
            matchedParams = {}
            isMatch = true

            for i = 0 to routeParts.count() - 1
                if routeParts[i].left(1) = ":" then
                    ' This is a parameter
                    paramName = routeParts[i].mid(1)
                    matchedParams[paramName] = pathParts[i]
                else if routeParts[i] <> pathParts[i] then
                    ' If a static part doesn't match, break
                    isMatch = false
                    exit for
                end if
            end for

            if isMatch then
                routeConfig = routes[routePath]
                ' Backfill routeConfig with default values
                routeConfig.canActivate = rodash.getArray(routeConfig, "canActivate")
                routeConfig.isRoot = rodash.getBoolean(routeConfig, "isRoot")
                routeConfig.isDialog = rodash.getBoolean(routeConfig, "isDialog")

                return {
                    path: path
                    routeConfig: routeConfig
                    routeParams: matchedParams
                    queryParams: queryParams
                    hash: hash
                    id: id
                    router: m.top
                }
            end if
        end if
    end for

    ' Return Route with empty routeConfig if no match found
    return {
        path: path
        routeConfig: {}
        routeParams: {}
        queryParams: queryParams
        hash: hash
        id: CreateObject("roDeviceInfo").GetRandomUUID()
        router: m.top
    }
end function

' Helper function to normalize a path
function normalizePath(path as String) as String
    path = path.trim()
    if path.right(1) = "/" then
        path = path.left(path.len() - 1)
    end if
    if path.left(1) <> "/" then
        path = "/" + path
    end if
    return path
end function

' Helper function to parse a query string into an associative array
function parseQueryString(queryString as Dynamic) as Object
    if NOT rodash.isNonEmptyString(queryString) then
        return {}
    end if

    queryParams = {}
    pairs = queryString.split("&")
    for each pair in pairs
        keyValue = pair.split("=")
        if keyValue.count() = 2 then
            key = keyValue[0]
            value = keyValue[1]
            queryParams[key] = value
        end if
    end for
    return queryParams
end function

function hideScreen(screen as Object, onSuspend = false as Boolean) as Boolean
    success = rodash.isNode(screen)
    if success then
        screen.visible = false
        screen.translation = [10000, 10000]

        if onSuspend then
            screen@._onScreenSuspend()
        end if
    end if
    return success
end function

' Tells the screen to open and fire the handleFocus lifecycle method
function showScreen(screen as Object, onResume = false as Boolean) as Dynamic
    if rodash.isNode(screen) then
        screen.visible = true
        screen.translation = [0, 0]
        m.activeScreen = screen

        response = Invalid
        if onResume then
            response = screen@._onScreenResume(screen.route)
        else
            response = screen@._onScreenOpen(screen.route)
        end if

        return promises.chain(response, { response: response, screen: screen }).finally(function(context as Dynamic) as Dynamic
            print "Screen opened", m.focusRequestMade
            focusSuccess = context.screen@._handleFocus({
                routerFocused: m.focusRequestMade
            })

            ' Return focus to the top node if the view didn't handle focus
            if m.focusRequestMade AND NOT focusSuccess then
                m.top.setFocus(true)
            end if

            m.processingGoBack = false
            dispatchRouterState(RouterStates.NavigationEnd, {
                id: context.screen.id
                route: context.screen.route
            })
            return context.response
        end function).toPromise()
    end if

    return promises.reject({ message: "Invalid screen" })
end function

function closeScreen(screen = Invalid as Dynamic) as Dynamic
    screen.translation = [1000000, 100000]
    screen.visible = false

    return promises.onThen(screen@._beforeScreenClose(screen.route), function(response as Dynamic, context as Dynamic) as Dynamic
        if hideScreen(context.screen) then
            rodash.removeNode(context.screen)
        end if

        return true
    end function, { screen: screen })
end function

function onKeyEvent(key = "" as String, press = false as Boolean) as Boolean
    if NOT press then return true

    if key = "back" then
        return goBack()
    end if

    return false
end function
