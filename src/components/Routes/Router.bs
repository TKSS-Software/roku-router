import "../../source/roku_modules/promises/promises.brs"
import "../../source/roku_modules/rodash/rodash.brs"

sub init()
    m.routes = {}
end sub

sub addRoutes(routes = [] as Object)
    for each route in routes
        m.routes[route.path] = route
    end for
end sub

function getRoutes(_ = invalid as dynamic) as dynamic
    return m.routes
end function

function navigateTo(path = "" as string, context = {} as Object) as dynamic
    matchedRoute = findMatchingRoute(path, m.routes)
    if matchedRoute <> invalid then
        activeScreen = m.top.activeScreen

        'TODO - Remove this when we have a proper context object
        if rodash.isNode(context) then
            context = context.getFields()
            context.delete("change")
            context.delete("focusable")
            context.delete("focusedChild")
            context.delete("ready")
        end if

        properties = {
            context: context
            route: matchedRoute["route"]
            routeParams: matchedRoute["params"]
            queryParams: matchedRoute["query"]
        }
        screenHash = md5(formatJson(properties))

        if activeScreen <> invalid and activeScreen.screenHash = screenHash
            return promises.reject({message: `Screen "${matchedRoute}" is already active`})
        end if

        'Check if the screen is already active
        properties["router"] = m.top
        properties["screenHash"] = screenHash
        screen = rodash.createNode(rodash.getString(matchedRoute, "route.component"), properties)

        if screen = invalid
            return promises.reject({message: `Failed to create screen "${matchedRoute["route"]["component"]}"`})
        end if

        return promises.chain(screen@._beforeScreenOpen(), screen).then(function(response as dynamic, screen as dynamic) as dynamic
            m.top.appendChild(screen)
            hideScreen(m.top.activeScreen)
            return showScreen(screen)
        end function).catch(function(error as dynamic) as dynamic
            return promises.reject(error)
        end function).toPromise()
    end if

    return promises.reject({message: `Route "${path}" not found`})
end function


' Helper function to find a matching route
function findMatchingRoute(path as String, routes as Object) as Object
    ' Separate the path from the query string
    pathParts = path.split("?")
    basePath = normalizePath(pathParts[0])
    queryString = invalid
    if pathParts.count() > 1
        queryString = pathParts[1]
    end if

    ' Parse the query string if present
    queryParams = parseQueryString(queryString)

    ' First check for exact matches (static paths)
    for each routePath in routes
        if normalizePath(routePath) = basePath
            return { 
                "route": routes[routePath], 
                "params": {}, 
                "query": queryParams 
            }
        end if
    end for

    ' Then check parameterized matches
    for each routePath in routes
        routeParts = normalizePath(routePath).split("/")
        pathParts = basePath.split("/")
        
        if routeParts.count() = pathParts.count()
            matchedParams = {}
            isMatch = true

            for i = 0 to routeParts.count() - 1
                if routeParts[i].left(1) = ":"
                    ' This is a parameter
                    paramName = routeParts[i].mid(1)
                    matchedParams[paramName] = pathParts[i]
                else if routeParts[i] <> pathParts[i]
                    ' If a static part doesn't match, break
                    isMatch = false
                    exit for
                end if
            end for

            if isMatch
                return { 
                    "route": routes[routePath], 
                    "params": matchedParams, 
                    "query": queryParams 
                }
            end if
        end if
    end for

    ' Return invalid if no match found
    return invalid
end function

' Helper function to normalize a path
function normalizePath(path as String) as String
    path = path.trim()
    if path.right(1) = "/"
        path = path.left(path.len() - 1)
    end if
    if path.left(1) <> "/"
        path = "/" + path
    end if
    return path
end function

' Helper function to parse a query string into an associative array
function parseQueryString(queryString as dynamic) as Object
    if type(queryString) <> "roString" or queryString = invalid or queryString.len() = 0
        return {}
    end if

    queryParams = {}
    pairs = queryString.split("&")
    for each pair in pairs
        keyValue = pair.split("=")
        if keyValue.count() = 2
            key = keyValue[0]
            value = keyValue[1]
            queryParams[key] = value
        end if
    end for
    return queryParams
end function


function md5(value as string) as string
    bytes = createObject("roByteArray")
    bytes.fromAsciiString(value) ' Convert whatever we get to a string
    ' Create the digest object for calculating the hash
    evpDigest = createObject("roEVPDigest")
    evpDigest.setup("md5")
    return evpDigest.process(bytes)
end function


function hideScreen(screen as object) as boolean
    success = rodash.isNode(screen)
    if success then
        screen.visible = false
        screen.translation = [10000, 10000]
    end if
    return success
end function

function showScreen(screen as object) as dynamic
    if rodash.isNode(screen) then
        screen.visible = true
        screen.translation = [0, 0]
        m.top.activeScreen = screen
        screen.setFocus(true)
        return screen@._onScreenOpen()
    end if

    return promises.reject({message: "Invalid screen"})
end function

function closeScreen(screen = invalid as dynamic) as dynamic
    screen.translation = [1000000, 100000]
    screen.visible = false

    return promises.onThen(screen@._beforeScreenClose(), function(response as dynamic, context as dynamic) as dynamic
        rodash.removeNode(context.screen)
        return true
    end function, { screen: screen })
end function

function onKeyEvent(key = "" as string, press = false as boolean) as boolean
    if not press then return true

    if key = "back" then
        screens = rodash.getNodeChildren(m.top)
        numberOfScreens = screens.count()
        if numberOfScreens <= 1 then return false

        promises.chain(closeScreen(screens.pop()), screens.peek()).then(sub(response as dynamic, screen as dynamic) as dynamic
            showScreen(screen)
        end sub)
        return true
    end if

    return false
end function


' TO BE IMPLEMENTED
function onMainSceneResume(_ as dynamic) as dynamic
    return promises.resolve(invalid)
end function