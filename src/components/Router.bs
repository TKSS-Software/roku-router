import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "pkg:/source/router.bs"

sub init()
    m.top.focusable = true
    m.top.observeField("focusedChild", "onFocusChildChanged")

    m.activeView = Invalid
    m.routes = {}
    m.guardInstances = {}

    m.focusRequestMade = false
    m.processingGoBack = false

    m.top.appLaunchComplete = false
end sub

sub onFocusChildChanged(event as Object)
    inFocusChain = event.getData() <> Invalid

    if NOT m.processingGoBack AND m.activeView <> Invalid AND NOT inFocusChain AND m.focusRequestMade <> inFocusChain then
        m.focusRequestMade = inFocusChain
        m.activeView@._handleFocus({
            routerFocused: inFocusChain
        })
    end if

    m.focusRequestMade = inFocusChain
end sub

function setFocus(takeFocus as Boolean) as Boolean
    print source_function_name, takeFocus
    response = false

    if m.activeView <> Invalid AND takeFocus AND m.focusRequestMade <> takeFocus then
        response = m.activeView@._handleFocus({
            routerFocused: true
        })
    end if

    m.focusRequestMade = true

    return response
end function

sub addRoutes(routes = [] as Object)
    for each route in routes
        m.routes[route.pattern] = route
    end for
end sub

' Function to get the routes
function getRoutes(_ = Invalid as Dynamic) as Dynamic
    return m.routes
end function

' Function to navigate back in the router history
function goBack(_ = Invalid as Dynamic) as Dynamic
    m.processingGoBack = true
    views = rodash.getNodeChildren(m.viewTarget)
    numberOfViews = views.count()
    if numberOfViews <= 1 then return false

    promises.chain(closeView(views.pop()), views.peek()).then(sub(response as Dynamic, view as Dynamic)
        m.focusRequestMade = m.focusRequestMade OR m.processingGoBack
        showView(view, {}, true)
    end sub)

    return true
end function

function dispatchRouterState(stateType as String, context = {} as Dynamic) as Dynamic
    update = {
        type: stateType
        id: rodash.getString(context, "route.id", context.id)
        route: rodash.get(context, "route")
    }

    if stateType = RouterStates.GuardResult then
        update.result = rodash.get(context, "result")
    end if
    m.top.routerState = update
    return promises.resolve(update)
end function

' Function to navigate to a specific route
function navigateTo(path = "" as String, options = {} as Object, context = {} as Object) as Dynamic
    id = CreateObject("roDeviceInfo").GetRandomUUID()
    matchedRoute = findMatchingRoute(path, m.routes, id)

    ' Prepare the function to support a queue
    return promises.chain(dispatchRouterState(RouterStates.NavigationStart, {
        id: id
        route: matchedRoute
    }), { id: id, matchedRoute: matchedRoute, options: options, context: context }).finally(function(context) as Dynamic
        id = context.id
        matchedRoute = context.matchedRoute
        options = context.options
        context = context.context

        if rodash.isNonEmptyAA(matchedRoute.routeConfig) then
            ' Run guard checks
            canActivateGuard = rodash.get(matchedRoute.routeConfig, "canActivate")
            dispatchRouterState(RouterStates.GuardsCheckStart, {
                id: id
                route: matchedRoute
            })
            if rodash.isNonEmptyArray(canActivateGuard) then
                for each guard in canActivateGuard
                    guardNode = Invalid
                    if rodash.isNode(guard) then
                        guardNode = guard
                    else if rodash.isString(guard) then
                        if m.guardInstances[guard] = Invalid then
                            m.guardInstances[guard] = rodash.createNode(guard)
                        end if

                        guardNode = m.guardInstances[guard]
                    end if

                    if guardNode <> Invalid then
                        canActivateResult = guardNode@.canActivate(matchedRoute)
                        print "canActivateResult", canActivateResult
                        dispatchRouterState(RouterStates.GuardResult, {
                            id: id
                            route: matchedRoute
                            type: "canActivate"
                            result: canActivateResult
                        })

                        if rodash.isBoolean(canActivateResult) then
                            canActivate = canActivateResult

                            if NOT canActivate then
                                message = { message: `Route "${path}" is not accessible` }
                                print message
                                dispatchRouterState(RouterStates.GuardsCheckEnd, {
                                    id: id
                                    route: matchedRoute
                                })
                                return promises.reject(message)
                            end if
                        else if rodash.isNonEmptyAA(canActivateResult) then
                            redirectTo = rodash.getString(canActivateResult, "path")
                            if rodash.isNonEmptyString(redirectTo) then
                                dispatchRouterState(RouterStates.GuardsCheckEnd, {
                                    id: id
                                    route: matchedRoute
                                })
                                return navigateTo(redirectTo, rodash.getAA(canActivateResult, "options"), rodash.getAA(canActivateResult, "context"))
                            end if
                        else
                            return promises.reject(message)
                        end if
                    end if
                end for
            end if

            dispatchRouterState(RouterStates.GuardsCheckEnd, {
                id: id
                route: matchedRoute
            })

            isRoot = matchedRoute.routeConfig.isRoot
            if isRoot then
                ' print "ROOT SCREEN"
            end if

            componentName = rodash.getString(matchedRoute, "routeConfig.component")
            if rodash.isEmptyString(componentName) then
                return promises.reject({ message: `No component for route "${path}"` })
            end if

            newRoute = {
                context: context
            }
            newRoute.append(matchedRoute)

            if m.activeView <> Invalid then
                oldRoute = m.activeView.route

                ' Reuse the view and call onRouteUpdate if the path or hash is the same, OR if the options allow it
                hasHash = rodash.isNonEmptyString(newRoute.hash)
                isSamePath = rodash.isEqual(newRoute.path, oldRoute.path)
                reuse = rodash.getBoolean(options, "allowReuse") OR hasHash OR isSamePath
                if hasHash then
                    if NOT rodash.isEqual(newRoute.routeConfig, oldRoute.routeConfig) then reuse = false
                else
                    if NOT rodash.isEqual(newRoute.routeParams.component, oldRoute.routeParams.component) then reuse = false
                end if

                if reuse then
                    m.activeView.route = newRoute
                    m.activeView@._onRouteUpdate({
                        oldRoute: oldRoute
                        newRoute: newRoute
                    })
                    return promises.resolve(m.activeView)
                end if
            end if

            view = rodash.createNode(componentName)
            if view = Invalid then
                return promises.reject({ message: `Failed to create view "${componentName}"` })
            end if

            view.id = newRoute.id
            view.route = newRoute
            view.router = m.top
            return promises.chain(view@._beforeViewOpen(newRoute), { view: view, newRoute: newRoute }).then(function(response as Dynamic, context as Dynamic) as Dynamic
                m.viewTarget.appendChild(context.view)
                hideView(m.activeView)
                return showView(context.view, context.newRoute)
            end function).catch(function(error as Dynamic) as Dynamic
                return promises.reject(error)
            end function).toPromise()
        end if

        dispatchRouterState(RouterStates.NavigationError, {
            id: id
        })
        message = { message: `Route "${path}" not found` }
        print message
        return promises.reject(message)
    end function).toPromise()
end function


' Helper function to find a matching route
function findMatchingRoute(path as String, routes as Object, id as String) as RouteObject
    hash = Router._utils.getHashParam(path)

    if rodash.isNonEmptyString(hash) then
        path = path.replace("#" + hash, "")
    end if

    ' Separate the path from the query string
    pathParts = path.split("?")
    basePath = normalizePath(pathParts[0])
    queryString = Invalid
    if pathParts.count() > 1 then
        queryString = pathParts[1]
    end if

    ' Parse the query string if present
    queryParams = parseQueryString(queryString)

    ' First check for exact matches (static paths)
    for each routePath in routes
        if normalizePath(routePath) = basePath then
            routeConfig = routes[routePath]
            ' Backfill routeConfig with default values
            routeConfig.canActivate = rodash.getArray(routeConfig, "canActivate")
            routeConfig.isRoot = rodash.getBoolean(routeConfig, "isRoot")
            routeConfig.isDialog = rodash.getBoolean(routeConfig, "isDialog")

            return {
                path: path
                routeConfig: routeConfig
                routeParams: {}
                queryParams: queryParams
                hash: hash
                id: id
                router: m.top
            }
        end if
    end for

    ' Then check parameterized matches
    for each routePath in routes
        routeParts = normalizePath(routePath).split("/")
        pathParts = basePath.split("/")

        matchedParams = {}
        if routeParts.count() = pathParts.count() then
            matchedParams = {}
            isMatch = true

            for i = 0 to routeParts.count() - 1
                if routeParts[i].left(1) = ":" then
                    ' This is a parameter
                    paramName = routeParts[i].mid(1)
                    matchedParams[paramName] = pathParts[i]
                else if routeParts[i] <> pathParts[i] then
                    ' If a static part doesn't match, break
                    isMatch = false
                    exit for
                end if
            end for

            if isMatch then
                routeConfig = routes[routePath]
                ' Backfill routeConfig with default values
                routeConfig.canActivate = rodash.getArray(routeConfig, "canActivate")
                routeConfig.isRoot = rodash.getBoolean(routeConfig, "isRoot")
                routeConfig.isDialog = rodash.getBoolean(routeConfig, "isDialog")

                return {
                    path: path
                    routeConfig: routeConfig
                    routeParams: matchedParams
                    queryParams: queryParams
                    hash: hash
                    id: id
                    router: m.top
                }
            end if
        end if
    end for

    ' Return Route with empty routeConfig if no match found
    return {
        path: path
        routeConfig: {}
        routeParams: {}
        queryParams: queryParams
        hash: hash
        id: CreateObject("roDeviceInfo").GetRandomUUID()
        router: m.top
    }
end function

' Helper function to normalize a path
function normalizePath(path as String) as String
    path = path.trim()
    if path.right(1) = "/" then
        path = path.left(path.len() - 1)
    end if
    if path.left(1) <> "/" then
        path = "/" + path
    end if
    return path
end function

' Helper function to parse a query string into an associative array
function parseQueryString(queryString as Dynamic) as Object
    if NOT rodash.isNonEmptyString(queryString) then
        return {}
    end if

    queryParams = {}
    pairs = queryString.split("&")
    for each pair in pairs
        keyValue = pair.split("=")
        if keyValue.count() = 2 then
            key = keyValue[0]
            value = keyValue[1]
            queryParams[key] = value
        end if
    end for
    return queryParams
end function

function hideView(view as Object, onSuspend = false as Boolean) as Boolean
    success = rodash.isNode(view)
    if success then
        view.visible = false
        view.translation = [10000, 10000]

        if onSuspend then
            view@._onViewSuspend()
        end if
    end if
    return success
end function

' Tells the view to open and fire the handleFocus lifecycle method
function showView(view as Object, params = {} as Dynamic, onResume = false as Boolean) as Dynamic
    if rodash.isNode(view) then
        view.visible = true
        view.translation = [0, 0]
        m.activeView = view

        response = Invalid
        if onResume then
            response = view@._onViewResume(params)
        else
            response = view@._onViewOpen(params)
        end if

        return promises.chain(response, { response: response, view: view }).finally(function(context) as Dynamic
            print "View opened", m.focusRequestMade
            focusSuccess = context.view@._handleFocus({
                routerFocused: m.focusRequestMade
            })

            ' Return focus to the top node if the view didn't handle focus
            if m.focusRequestMade AND NOT focusSuccess then
                m.top.setFocus(true)
            end if

            m.processingGoBack = false
            dispatchRouterState(RouterStates.NavigationEnd, {
                id: context.view.id
                route: context.view.route
            })
            return context.response
        end function).toPromise()
    end if

    return promises.reject({ message: "Invalid view" })
end function

function closeView(view = Invalid as Dynamic) as Dynamic
    view.translation = [1000000, 100000]
    view.visible = false

    return promises.onThen(view@._beforeViewClose(view.route), function(response as Dynamic, context as Dynamic) as Dynamic
        if hideView(context.view) then
            rodash.removeNode(context.view)
        end if

        return true
    end function, { view: view })
end function

function onKeyEvent(key = "" as String, press = false as Boolean) as Boolean
    if NOT press then return true

    if key = "back" then
        return goBack()
    end if

    return false
end function
