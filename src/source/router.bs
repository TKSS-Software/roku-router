import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "interfaces.bs"
import "RouterState.bs"

'************************
'*** This namespace can be used inside any component that is a view, or child of a view
'*** DO NOT USE THIS FILE OUTSIDE OF A VIEW COMPONENT, such as the main scene
'************************
namespace rokuRouter
    function initialize(params = {} as Object) as Dynamic
        routerObject = Invalid
        if params.router = Invalid then
            routerObject = createObject("roSGNode", "Router")
        else
            routerObject = params.router
        end if

        if params.outlet = Invalid then
            params.outlet = rokuRouter.searchForOutlet(m.top.getScene())
        end if

        ' Validate the outlet
        if rodash.isNode(routerObject) AND routerObject.hasField("__isRouter") AND rodash.isNode(params.outlet) AND params.outlet.hasField("__isOutlet") then
            m.top.getScene().addFields({ __router: routerObject })
            return routerObject@._initialize(params)
        end if

        return Invalid
    end function

    ' This function is used to navigate to a different screen
    ' It will return a promise that will resolve when the navigation is complete
    ' @since 0.0.1
    ' @param path - The path to navigate to
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    ' @return - A promise that will resolve when the navigation is complete
    function navigateTo(path = "" as String, options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._navigateTo(path, options)
        end if
        return promises.resolve(true)
    end function

    function goBack(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._goBack(Invalid)
        end if
        return false
    end function

    ' This function is used to add routes to the router
    ' @since 0.0.1
    ' @param routes - The routes to add
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    sub addRoutes(routes = [] as Object, options = {} as Object)
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            r@._addRoutes(routes)
        end if
    end sub

    ' This function is used to get all routes from the router
    ' @since 0.0.1
    ' @return - All routes from the router
    function getRoutes(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._getRoutes()
        end if
        return {}
    end function

    ' Gets the router from the global scope. Creates the router if it does not exist.
    ' @since 0.0.1
    ' @return - The router
    function getRouter() as Dynamic
        return m.top.getScene().__router
    end function

    function searchForOutlet(parent = Invalid as Dynamic, depth = 0 as Integer) as Dynamic
        ' Stop if too deep
        if depth > 30 then
            return Invalid
        end if

        if parent = Invalid then
            parent = m.top
        end if

        outlet = Invalid

        'Look top level
        for each node in rodash.getNodeChildren(parent)
            if rodash.isNode(node) AND node.hasField("__isOutlet") then
                outlet = node
            else
                outlet = searchForOutlet(node, depth + 1)
            end if

            if outlet <> Invalid then
                return outlet
            end if
        end for

        return Invalid
    end function

    function setFocus(options = {} as Object) as Boolean
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) AND rodash.isBoolean(options.focus) then
            return r@._setFocus(options.focus)
        end if
        return false
    end function

    ' This function is used to create a redirect command
    ' Redirect commands are used to redirect the user to a different screen during a guard check
    ' @since 0.0.1
    ' @param path - The path to redirect to
    ' @param routeConfigOverrides - The route config overrides to apply to the new route
    ' @param context - The context to pass to the router
    ' @return - A redirect command
    function createRedirectCommand(path = "" as String, routeConfigOverrides = {} as Object, context = {} as Object) as Dynamic
        return {
            command: "RedirectCommand"
            path: path
            routeConfigOverrides: routeConfigOverrides
            context: context
        }
    end function

end namespace

namespace rokuRouter.utils
    ' Helper function to dispatch a router state' @param {String} stateType - The type of state to dispatch
    ' @param {Object} context - The context to pass to the state
    sub dispatchRouterState(stateType as String, context = {} as Dynamic)
        update = {
            type: stateType
            id: rodash.getString(context, "route.id", context.id)
            state: {}
        }

        if rodash.isAA(context.error) then
            update.error = context.error
        end if

        if rodash.isNode(context.route) then
            route = context.route
            update.state = createRouteSnapshot(route)
            update.url = route.path
        end if

        rokuRouter.getRouter().routerState = update
    end sub

    function createRouteSnapshot(route as Object) as Object
        return {
            routeConfig: route.routeConfig
            queryParams: route.queryParams
            routeParams: route.routeParams
            hash: route.hash
        }
    end function

    ' Helper function to create a route object' @param {Object} config - The configuration object
    ' @returns {Dynamic} - The result of the view open
    function createRouteObject(config = {} as Object) as Object
        id = CreateObject("roDeviceInfo").GetRandomUUID()
        return {
            path: rodash.getString(config, "path")
            routeConfig: rodash.getAA(config, "routeConfig")
            context: rodash.merge(createBaseContext(), rodash.getAA(config, "context"))
            navigationState: createBaseNavigationState()
            routeParams: rodash.getAA(config, "routeParams")
            queryParams: rodash.getAA(config, "queryParams")
            hash: rodash.getString(config, "hash")
            id: id
            syncId: id
            parentRendered: false
            router: m.top
        }
    end function

    ' Helper function to create a base context object' @returns {Object} - The base context object
    function createBaseContext() as Object
        return {}
    end function

    function createBaseNavigationState() as Object
        return {
            fromRedirect: false
            fromSuspendedRoot: false
            fromPopState: false
            fromPushState: false
        }
    end function

    ' Helper function to find a matching route' @param {String} path - The path to find a matching route for
    ' @param {Object} routes - The routes to search
    ' @returns {Dynamic} - The matching route
    function findMatchingRoute(path as String, routes as Object) as RouteObject
        hash = getHashParam(path)

        if rodash.isNonEmptyString(hash) then
            path = path.replace("#" + hash, "")
        end if

        ' Separate the path from the query string
        pathParts = path.split("?")
        basePath = normalizePath(pathParts[0])
        queryString = Invalid
        if pathParts.count() > 1 then
            queryString = pathParts[1]
        end if

        ' Parse the query string if present
        queryParams = parseQueryString(queryString)

        ' First check for exact matches (static paths)
        for each routePath in routes
            if normalizePath(routePath) = basePath then
                return createRouteObject({
                    path: path
                    routeConfig: routes[routePath]
                    queryParams: queryParams
                    hash: hash
                })
            end if
        end for

        ' Then check parameterized matches
        for each routePath in routes
            routeParts = normalizePath(routePath).split("/")
            pathParts = basePath.split("/")

            matchedParams = {}
            if routeParts.count() = pathParts.count() then
                matchedParams = {}
                isMatch = true

                for i = 0 to routeParts.count() - 1
                    if routeParts[i].left(1) = ":" then
                        ' This is a parameter
                        paramName = routeParts[i].mid(1)
                        matchedParams[paramName] = pathParts[i]
                    else if routeParts[i] <> pathParts[i] then
                        ' If a static part doesn't match, break
                        isMatch = false
                        exit for
                    end if
                end for

                if isMatch then
                    return createRouteObject({
                        path: path
                        routeConfig: routes[routePath]
                        routeParams: matchedParams
                        queryParams: queryParams
                        hash: hash
                    })
                end if
            end if
        end for

        return createRouteObject({
            path: path
            queryParams: queryParams
            hash: hash
        })
    end function

    ' Helper Function to get the hash parameter from a URL' @param {String} url - The URL to get the hash parameter from
    ' @returns {String} - The hash parameter
    function getHashParam(url as String) as String
        ' Check if the input URL is valid
        if rodash.isEmptyString(url) then
            return ""
        end if

        ' Find the position of the # character in the URL
        hashIndex = rodash.stringIndexOf(url, "#")

        ' If # is not found, return "Invalid"
        if hashIndex = -1 then
            return ""
        end if

        ' Extract and return the substring after the #
        return url.mid(hashIndex + 1)
    end function

    ' Helper function to normalize a path' @param {String} path - The path to normalize
    ' @returns {String} - The normalized path
    function normalizePath(path as String) as String
        path = path.trim()
        if path.right(1) = "/" then
            path = path.left(path.len() - 1)
        end if
        if path.left(1) <> "/" then
            path = "/" + path
        end if
        return path
    end function

    ' Helper function to parse a query string into an associative array' @param {Dynamic} queryString - The query string to parse
    ' @returns {Object} - The parsed query string
    function parseQueryString(queryString as Dynamic) as Object
        if NOT rodash.isNonEmptyString(queryString) then
            return {}
        end if

        queryParams = {}
        pairs = queryString.split("&")
        for each pair in pairs
            keyValue = pair.split("=")
            if keyValue.count() = 2 then
                key = keyValue[0]
                value = keyValue[1]
                queryParams[key] = value
            end if
        end for
        return queryParams
    end function

    ' This function is used to get the current focused chain of nodes
    ' @since 0.0.1
    ' @param parent - The parent node to start the search from
    ' @param maxDepth - The maximum depth to search
    ' @return - The chain of nodes
    function getCurrentFocusedChain(parent = Invalid as Object, maxDepth = 30 as Integer) as Object
        if rodash.isNode(parent) then
            targetNode = parent
        else
            targetNode = m.top.getScene()
        end if

        focusedChild = targetNode.focusedChild

        chain = [targetNode]

        if rodash.isNode(focusedChild) then
            while maxDepth > 0 AND NOT rodash.isEqual(focusedChild, targetNode)
                targetNode = focusedChild

                ' There is a chance the chain is incomplete
                if targetNode = Invalid then exit while
                chain.push(targetNode)
                focusedChild = targetNode.focusedChild 'bs:disable-line LINT1005
                maxDepth--
            end while

            return chain
        end if

        return chain
    end function
end namespace
