import "pkg:/source/roku_modules/promises/promises.brs"
import "pkg:/source/roku_modules/rodash/rodash.brs"
import "interfaces.bs"
import "RouterState.bs"

'************************
'*** This namespace can be used inside any component that is a view, or child of a view
'*** DO NOT USE THIS FILE OUTSIDE OF A VIEW COMPONENT, such as the main scene
'************************
namespace rokuRouter

    function initialize(params = {} as Object) as Dynamic
        routerObject = Invalid
        if params.router = Invalid then
            routerObject = createObject("roSGNode", "Router")
        else
            routerObject = params.router
        end if

        if params.outlet = Invalid then
            params.outlet = rokuRouter.searchForOutlet(m.top.getScene())
        end if

        ' Validate the outlet
        if rokuRouter.utils.isRouter(routerObject) AND rokuRouter.utils.isOutlet(params.outlet) then
            scene = m.top.getScene()
            if scene.hasField("__router") then
                scene.removeField("__router")
            end if
            scene.addFields({ __router: routerObject })

            return routerObject@._initialize(params)
        end if

        return Invalid
    end function

    ' This function is used to navigate to a different screen
    ' It will return a promise that will resolve when the navigation is complete
    ' @since 0.0.1
    ' @param path - The path to navigate to
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    ' @return - A promise that will resolve when the navigation is complete
    function navigateTo(path = "" as String, options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._navigateTo(path, options)
        end if
        return promises.resolve(true)
    end function

    function goBack(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r@._goBack(Invalid)
        end if
        return false
    end function

    ' This function is used to add routes to the router
    ' @since 0.0.1
    ' @param routes - The routes to add
    ' @param options - The options to pass to the router
    ' @param options.router - The router to use, if not provided, it will try to find the router in the current chain
    sub addRoutes(routes = [] as Object, options = {} as Object)
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            _routes = rodash.merge({}, r.__router_routes)

            for each route in routes
                if rokuRouter.utils.isValidRoute(route) then
                    _routes[route.pattern] = route
                end if
            end for
            r.__router_routes = _routes
        end if
    end sub

    ' This function is used to get all routes from the router
    ' @since 0.0.1
    ' @return - All routes from the router
    function getRoutes(options = {} as Object) as Dynamic
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) then
            return r.__router_routes
        end if
        return {}
    end function

    ' Gets the router from the global scope. Creates the router if it does not exist.
    ' @since 0.0.1
    ' @return - The router
    function getRouter() as Dynamic
        return m.top.getScene().__router
    end function

    function searchForOutlet(parent = Invalid as Dynamic) as Dynamic
        if parent = Invalid then
            parent = m.top
        end if

        ' Check to see if you are in the outlet
        if rokuRouter.utils.isOutlet(parent) then
            return node
        end if

        nodes = rodash.getNodeChildren(parent)
        while nodes.count() > 0
            node = nodes.Shift()
            if rokuRouter.utils.isOutlet(node) then
                return node
            else
                'push all of this node's children to be searched in the future
                nodes.append(rodash.getNodeChildren(node))
            end if
        end while

        return Invalid
    end function

    function setFocus(options = {} as Object) as Boolean
        r = options.router <> Invalid ? options.router : rokuRouter.getRouter()
        if rodash.isNotInvalid(r) AND rodash.isBoolean(options.focus) then
            return r@._setFocus(options.focus)
        end if
        return false
    end function

    ' This function is used to create a redirect command
    ' Redirect commands are used to redirect the user to a different screen during a guard check
    ' @since 0.0.1
    ' @param path - The path to redirect to
    ' @param routeConfigOverrides - The route config overrides to apply to the new route
    ' @param context - The context to pass to the router
    ' @return - A redirect command
    function createRedirectCommand(path = "" as String, routeConfigOverrides = {} as Object, context = {} as Object) as Dynamic
        return {
            command: "RedirectCommand"
            path: path
            routeConfigOverrides: routeConfigOverrides
            context: context
        }
    end function

end namespace

namespace rokuRouter.utils
    ' Helper function to create a route object' @param {Object} config - The configuration object
    ' @returns {Dynamic} - The result of the view open
    function createRouteObject(config = {} as Object) as Object
        return {
            path: rodash.getString(config, "path")
            routeConfig: rodash.merge({
                pattern: ""
                component: ""
                allowReuse: false
                canActivate: []
                isRoot: false
                keepRootAlive: false
                isDialog: false
            }, rodash.getAA(config, "routeConfig"))
            context: rodash.getAA(config, "context")
            navigationState: {
                fromRedirect: false
                fromSuspendedRoot: false
                fromPopState: false
                fromPushState: false
            }
            routeParams: rodash.getAA(config, "routeParams")
            queryParams: rodash.getAA(config, "queryParams")
            hash: rodash.getString(config, "hash")
            id: CreateObject("roDeviceInfo").GetRandomUUID()
            router: m.top
        }
    end function

    function isOutlet(node = Invalid as Object) as Boolean
        return rodash.isNode(node) AND node.hasField("__isOutlet")
    end function

    function isRouter(node = Invalid as Object) as Boolean
        return rodash.isNode(node) AND node.hasField("__isRouter")
    end function

    ' Helper function to find a matching route' @param {String} path - The path to find a matching route for
    ' @returns {Dynamic} - The matching route
    function findMatchingRouteConfig(path as String) as RouteObject
        hash = rokuRouter.utils.getHashParam(path)

        if rodash.isNonEmptyString(hash) then
            path = path.replace("#" + hash, "")
        end if

        ' Separate the path from the query string
        pathParts = path.split("?")
        basePath = rokuRouter.utils.normalizePath(pathParts[0])
        queryString = Invalid
        if pathParts.count() > 1 then
            queryString = pathParts[1]
        end if

        ' Parse the query string if present
        queryParams = rokuRouter.utils.parseQueryString(queryString)

        ' First check for exact matches (static paths)
        routes = getFlattenedRouteConfigs()
        for each routePath in routes
            if rokuRouter.utils.normalizePath(routePath) = basePath then
                return rokuRouter.utils.createRouteObject({
                    path: path
                    routeConfig: routes[routePath]
                    queryParams: queryParams
                    hash: hash
                })
            end if
        end for

        ' Then check parameterized matches
        for each routePath in routes
            routeParts = rokuRouter.utils.normalizePath(routePath).split("/")
            pathParts = basePath.split("/")

            matchedParams = {}
            if routeParts.count() = pathParts.count() then
                matchedParams = {}
                isMatch = true

                for i = 0 to routeParts.count() - 1
                    if routeParts[i].left(1) = ":" then
                        ' This is a parameter
                        paramName = routeParts[i].mid(1)
                        matchedParams[paramName] = pathParts[i]
                    else if routeParts[i] <> pathParts[i] then
                        ' If a static part doesn't match, break
                        isMatch = false
                        exit for
                    end if
                end for

                if isMatch then
                    return rokuRouter.utils.createRouteObject({
                        path: path
                        routeConfig: routes[routePath]
                        routeParams: matchedParams
                        queryParams: queryParams
                        hash: hash
                    })
                end if
            end if
        end for

        return rokuRouter.utils.createRouteObject({
            path: path
            queryParams: queryParams
            hash: hash
        })
    end function

    ' Helper function to normalize a path' @param {String} path - The path to normalize
    ' @returns {String} - The normalized path
    function normalizePath(path as String) as String
        path = path.trim()
        if path.right(1) = "/" then
            path = path.left(path.len() - 1)
        end if
        if path.left(1) <> "/" then
            path = "/" + path
        end if
        return path
    end function

    ' This function is used to get the current focused chain of nodes
    ' @since 0.0.1
    ' @param parent - The parent node to start the search from
    ' @param maxDepth - The maximum depth to search
    ' @return - The chain of nodes
    function getCurrentFocusedChain(parent = Invalid as Object, maxDepth = 30 as Integer) as Object
        if rodash.isNode(parent) then
            targetNode = parent
        else
            targetNode = m.top.getScene()
        end if

        focusedChild = targetNode.focusedChild

        chain = [targetNode]

        if rodash.isNode(focusedChild) then
            while maxDepth > 0 AND NOT rodash.isEqual(focusedChild, targetNode)
                targetNode = focusedChild

                ' There is a chance the chain is incomplete
                if targetNode = Invalid then exit while
                chain.push(targetNode)
                focusedChild = targetNode.focusedChild 'bs:disable-line LINT1005
                maxDepth--
            end while

            return chain
        end if

        return chain
    end function

    ' Helper Function to get the hash parameter from a URL' @param {String} url - The URL to get the hash parameter from
    ' @returns {String} - The hash parameter
    function getHashParam(url as String) as String
        ' Check if the input URL is valid
        if rodash.isEmptyString(url) then
            return ""
        end if

        ' Find the position of the # character in the URL
        hashIndex = rodash.stringIndexOf(url, "#")

        ' If # is not found, return "Invalid"
        if hashIndex = -1 then
            return ""
        end if

        ' Extract and return the substring after the #
        return url.mid(hashIndex + 1)
    end function

    ' Helper function to parse a query string into an associative array' @param {Dynamic} queryString - The query string to parse
    ' @returns {Object} - The parsed query string
    function parseQueryString(queryString as Dynamic) as Object
        if NOT rodash.isNonEmptyString(queryString) then
            return {}
        end if

        queryParams = {}
        pairs = queryString.split("&")
        for each pair in pairs
            keyValue = pair.split("=")
            if keyValue.count() = 2 then
                key = keyValue[0]
                value = keyValue[1]
                queryParams[key] = value
            end if
        end for
        return queryParams
    end function

    ' Function to get the flattened routes' @returns {Array} - The flattened routes
    ' @returns {Array} - The flattened routes
    function getFlattenedRouteConfigs(_ = Invalid as Dynamic) as Dynamic
        flattedRoutesObject = {}
        for each key in rokuRouter.getRouter().__router_routes
            flattenRoute(rokuRouter.getRouter().__router_routes[key], "", flattedRoutesObject)
        end for
        return flattedRoutesObject
    end function

    ' Function to flatten a route' @param {Object} route - The route to flatten
    ' @param {Object} route - The route to flatten
    ' @param {String} parentPattern - The parent pattern
    ' @param {Object} flattedRoutesObject - The flatted routes object to merge
    ' @returns {Object} - The flatted routes object
    function flattenRoute(route = {} as Object, parentPattern = "" as String, flattedRoutesObject = {} as Object) as Object
        if isValidRoute(route) then
            route.pattern = parentPattern + rokuRouter.utils.normalizePath(route.pattern)

            if rodash.isNonEmptyArray(route.children) then
                children = route.children
                route.delete("children")

                while children.count() > 0
                    flattenRoute(rodash.merge({}, [route, children.Shift(), {
                            parent: route.pattern
                    }]), route.pattern, flattedRoutesObject)
                end while
            end if

            route.delete("children")
            flattedRoutesObject[route.pattern] = route
        end if

        return flattedRoutesObject
    end function

    function isValidRoute(route as Object) as Boolean
        if rodash.isNonEmptyString(route.pattern) AND rodash.isNonEmptyString(route.component) then return true

        print "Invalid route", route
        return false
    end function
end namespace
