import "pkg:/source/router.bs"

sub init()
    m.top.focusable = true
    m.top.breadCrumbs = []
    m.viewTarget = m.top.findNode("viewTarget")
    m.suspendedViewTarget = m.top.findNode("suspendedViewTarget")
    m.firstRequestMade = false
end sub

function _processNavigation(newRoute as Dynamic) as Dynamic
    if NOT m.firstRequestMade then
        m.firstRequestMade = true

        router = rokuRouter.getRouter()
    end if
    id = newRoute.id

    ' Look for a matched pattern
    if rodash.isNonEmptyString(newRoute.routeConfig.pattern) then
        if rodash.isEmptyString(newRoute.routeConfig.component) then
            message = { message: `No component for route "${newRoute.path}"` }
            if m.top.isTopOutlet then
                rokuRouter.utils.dispatchRouterState(RouterState.NavigationError, {
                    id: id
                    error: message
                })
            end if
            return promises.reject(message)
        end if

        viewsToRemove = []
        if m.top.activeView <> Invalid then
            oldRoute = m.top.activeView.route

            ' Reuse the view and call onRouteUpdate if the path or hash is the same, OR if the routeConfig override allows it
            hasHash = rodash.isNonEmptyString(newRoute.hash)
            isSamePath = rodash.isEqual(newRoute.path, oldRoute.path)
            hasSameParent = newRoute.parentRendered AND newRoute.parentPath <> "" AND rodash.isEqual(newRoute.parentPath, oldRoute.parentPath)
            hasSameSyncId = rodash.isEqual(newRoute.syncId, oldRoute.syncId)
            reuse = rodash.getBoolean(newRoute.routeConfig, "allowReuse") OR hasHash OR isSamePath OR (hasSameParent AND NOT hasSameSyncId)
            if hasHash then
                if NOT rodash.isEqual(newRoute.routeConfig, oldRoute.routeConfig) then reuse = false
            else
                if NOT rodash.isEqual(newRoute.routeParams.component, oldRoute.routeParams.component) then reuse = false
            end if

            if reuse then
                if m.top.isTopOutlet then
                    rokuRouter.utils.dispatchRouterState(RouterState.ResolveStart, {
                        id: id
                        route: newRoute
                    })
                end if

                ' m.top.activeView.route = newRoute TYLER CHECK!
                return promises.chain(m.top.activeView@._onRouteUpdate({ oldRoute: oldRoute, newRoute: newRoute }), newRoute).then(function(response as Dynamic, route as Dynamic) as Dynamic
                    if m.top.isTopOutlet then
                        rokuRouter.utils.dispatchRouterState(RouterState.ResolveEnd, {
                            id: route.id
                            route: route
                        })
                        rokuRouter.utils.dispatchRouterState(RouterState.ActivationEnd, {
                            id: route.id
                            route: route
                        })
                        rokuRouter.utils.dispatchRouterState(RouterState.NavigationEnd, {
                            id: route.id
                            route: route
                        })
                    end if

                    return promises.resolve(m.top.activeView)
                end function).toPromise()
            else
                if rodash.getBoolean(newRoute, "routeConfig.isRoot") then
                    for each view in rodash.getNodeChildren(m.viewTarget)
                        ' print "view to remove", view
                        viewsToRemove.push(view)
                    end for
                end if
            end if
        end if

        newRoute.navigationState = rodash.merge(newRoute.navigationState, {
            fromPopState: false
            fromPushState: true
        })

        return promises.chain(addViewToStack(newRoute, viewsToRemove), newRoute).then(function(response as Dynamic, route as Dynamic) as Dynamic
            if NOT route.navigationState.fromPopState then
                breadCrumbs = []
                if NOT route.routeConfig.isRoot then
                    breadCrumbs.append(m.top.breadCrumbs)
                end if
                breadCrumbs.push(route)
                m.top.breadCrumbs = breadCrumbs
            end if

            return response
        end function).toPromise
    end if

    message = { message: `Route "${newRoute.path}" not found` }
    if m.top.isTopOutlet then
        rokuRouter.utils.dispatchRouterState(RouterState.NavigationError, {
            id: id
            error: message
        })
    end if

    return promises.reject(message)
end function

' Function to add a view to the view stack' @param {Dynamic} route - The route to add to the view stack
' @param {Array} closeViews - The views to close
' @returns {Dynamic} - The result of the view stack management
function addViewToStack(route as Dynamic, closeViews = [] as Object) as Dynamic
    ' An event triggered at the start of the Resolve phase of routing.
    if m.top.isTopOutlet then
        rokuRouter.utils.dispatchRouterState(RouterState.ResolveStart, {
            id: route.id
            route: route
        })
    end if

    ' Look to see if the root view is suspended
    suspendedRootView = Invalid
    for each view in rodash.getNodeChildren(m.suspendedViewTarget)
        ' print "view.route.pattern", view.route.path, route.path
        if view.route.path = route.path then
            suspendedRootView = view

            route.navigationState = rodash.merge(route.navigationState, {
                fromSuspendedRoot: true
            })
            exit for
        end if
    end for

    toResolve = promises.resolve(true)
    if suspendedRootView <> Invalid then
        view = suspendedRootView
        view.id = route.id
        view.route = route
    else
        parent = route.routeConfig.parent
        componentSource = route

        if route.parentRendered = false AND rodash.isNonEmptyString(parent) then
            routes = rokuRouter.getRoutes()
            parentRoute = rokuRouter.utils.findMatchingRoute(parent, rokuRouter.getRoutes())

            if parentRoute = Invalid then
                error = { message: `Parent route "${parent}" not found` }
                if m.top.isTopOutlet then
                    rokuRouter.utils.dispatchRouterState(RouterState.NavigationError, {
                        id: route.id
                        error: error
                        route: route
                    })
                end if
                print error
                return promises.reject(error)
            else
                componentSource = parentRoute
            end if


        end if

        componentName = rodash.getString(componentSource, "routeConfig.component")


        ' Create the view and hide it to prevent using texture memory until it is ready to be shown
        view = rodash.createNode(componentName, {
            visible: false
            translation: [10000, 10000]
            id: route.id
            route: route
            router: m.top
        })

        if view = Invalid then
            return promises.reject({ message: `Failed to create view "${componentName}"` })
        end if

        toResolve = view@._beforeViewOpen({ route: route })
    end if

    return promises.chain(toResolve, { view: view, closeViews: closeViews, fromSuspend: suspendedRootView <> Invalid }).then(function(response as Dynamic, internalContext as Dynamic) as Dynamic
        view = internalContext.view
        m.viewTarget.appendChild(view)
        view.reparent(m.viewTarget, true) ' in the event the view was previously suspended
        hideView(m.top.activeView)

        promisesToResolve = [promises.resolve(true)]
        if rodash.isNonEmptyArray(internalContext.closeViews) then
            for each view in internalContext.closeViews
                params = {
                    route: view.route
                }
                if view.route.routeConfig.isRoot AND view.route.routeConfig.keepRootAlive then
                    promisesToResolve.push(view@._onViewSuspend(params))
                else
                    promisesToResolve.push(view@._beforeViewClose(params))
                end if
            end for
        end if

        return promises.all(promisesToResolve)
    end function).then(function(_ as Dynamic, internalContext as Dynamic) as Dynamic
        if NOT m.top.isTopOutlet then
            'An event triggered at the end of the activation part of the Resolve phase of routing.
            rokuRouter.utils.dispatchRouterState(RouterState.ActivationEnd, {
                id: internalContext.view.id
                route: internalContext.view.route
            })

            ' An event triggered at the end of the Resolve phase of routing.
            rokuRouter.utils.dispatchRouterState(RouterState.ResolveEnd, {
                id: internalContext.view.id
                route: internalContext.view.route
            })
        end if

        'now that all of the `beforeViewClose` promises have resolved, show the new view
        return showView(internalContext.view, internalContext.fromSuspend)
    end function).then(function(response as Dynamic, internalContext as Dynamic) as Dynamic
        if rodash.isNonEmptyArray(internalContext.closeViews) then
            for each view in internalContext.closeViews
                if view.route.routeConfig.isRoot AND view.route.routeConfig.keepRootAlive then
                    if hideView(view) AND view.reparent(m.suspendedViewTarget, true) then
                        m.suspendedViewTarget.appendChild(view)
                    end if
                else
                    if hideView(view) then rodash.removeNode(view)
                end if
            end for
        end if

        return response
    end function).catch(function(error as Dynamic) as Dynamic
        return promises.reject(error)
    end function).toPromise()
end function

' Function to close a view' @param {Dynamic} view - The view to close
' @returns {Dynamic} - The result of the view close
function closeView(view = Invalid as Dynamic) as Dynamic
    view.translation = [1000000, 100000]
    view.visible = false

    return promises.onThen(view@._beforeViewClose({ route: view.route }), function(response as Dynamic, internalContext as Dynamic) as Dynamic
        if hideView(internalContext.view) then
            rodash.removeNode(internalContext.view)
        end if

        return true
    end function, { view: view })
end function

' Tells the view to hide and fire the onViewSuspend lifecycle method if onSuspend is true' @param {Object} view - The view to hide
' @param {Boolean} onSuspend - Whether to fire the onViewSuspend lifecycle method
function hideView(view as Object, onSuspend = false as Boolean) as Boolean
    success = rodash.isNode(view)
    if success then
        view.visible = false
        view.translation = [10000, 10000]

        if onSuspend then
            view@._onViewSuspend({ route: view.route })
        end if
    end if
    return success
end function

' Tells the view to open and fire the handleFocus lifecycle method' @param {Object} view - The view to show
' @param {Boolean} onResume - Whether the view is being resumed
function showView(view as Object, onResume = false as Boolean) as Dynamic
    if rodash.isNode(view) then
        view.visible = true
        view.translation = [0, 0]
        m.top.activeView = view

        response = Invalid
        params = {
            route: view.route
        }
        if onResume then
            response = view@._onViewResume(params)
        else
            response = view@._onViewOpen(params)
        end if

        return promises.chain(response, { response: response, view: view, onResume: onResume }).finally(function(context as Dynamic) as Dynamic
            focusSuccess = context.view@._handleFocus({
                routerHasFocus: rokuRouter.getRouter().inFocusChain
                outletInFocusChain: m.top.inFocusChain
            })

            ' Return focus to the top node if the view didn't handle focus
            if m.top.inFocusChain AND NOT focusSuccess then
                print "Error giving focus. Don't do anything"
            end if

            rokuRouter.utils.dispatchRouterState(RouterState.NavigationEnd, {
                id: context.view.id
                route: context.view.route
            })
            rokuRouter.getRouter().processingGoBack = false
            return context.response
        end function).toPromise()
    end if

    return promises.reject({ message: "Invalid view" })
end function

function navigateTo(route as Dynamic, closeViews = [] as Object) as Dynamic
    return addViewToStack(route, closeViews)
end function

function setFocus(takeFocus = true as Boolean) as Boolean
    m.top.inFocusChain = takeFocus

    return _handleFocus({
        outletInFocusChain: takeFocus
    })
end function

function _handleFocus(data = {} as Object) as Boolean
    if m.top.activeView = Invalid then return false

    data = rodash.merge({
        routerHasFocus: rokuRouter.getRouter().inFocusChain
        outletInFocusChain: m.top.inFocusChain
    }, data)

    return m.top.activeView@._handleFocus(data)
end function

function _goBack(_ = Invalid as Dynamic) as Boolean
    r = rokuRouter.getRouter()
    ' Do not allow goBack if a route is updating.
    ' Perhaps we should allow this in the future, but for now, it's a bit too complex.
    if r.processingRouteUpdate then return true

    numberOfViews = m.top.breadCrumbs.count()
    if numberOfViews <= 1 then
        return false
    end if

    r.processingGoBack = true

    activeView = m.top.activeView
    childOutlet = activeView.childOutlet

    breadCrumbs = []
    breadCrumbs.append(m.top.breadCrumbs)

    routeToClose = breadCrumbs[numberOfViews - 1]
    routeToOpen = breadCrumbs[numberOfViews - 2]
    viewToOpen = Invalid
    viewToClose = Invalid

    for each view in rodash.getNodeChildren(m.viewTarget)
        if rodash.isEqual(view.route, routeToOpen) then viewToOpen = view
        if rodash.isEqual(view.route, routeToClose) then viewToClose = view
    end for

    if viewToOpen = Invalid OR viewToClose = Invalid then
        return false
    end if

    viewToOpen.route.navigationState = rodash.merge(viewToOpen.route.navigationState, {
        fromSuspendedRoot: false
        fromPopState: true
        fromPushState: false
        fromRedirect: false
    })

    if rodash.isNode(childOutlet) then
        if childOutlet@._goBack() then
            m.top.breadCrumbs = breadCrumbs
            return true
        end if
    end if

    ' An event triggered when a navigation starts.
    rokuRouter.utils.dispatchRouterState(RouterState.NavigationStart, {
        id: viewToOpen.route.id
    })

    promises.chain(closeView(viewToClose), { viewToOpen: viewToOpen, breadCrumbs: breadCrumbs }).then(sub(response as Dynamic, context as Dynamic)
        showView(context.viewToOpen, true)
        context.breadCrumbs.pop()
        m.top.breadCrumbs = context.breadCrumbs
    end sub).toPromise()

    return true
end function


' Handles the goBack calls when the "back" key is pressed' @param {String} key - The key that was pressed
' @param {Boolean} press - Whether the key was pressed or released
' @returns {Boolean} - Whether the view was hidden or not
function onKeyEvent(key = "" as String, press = false as Boolean) as Boolean
    if NOT press then return true

    ' Only capture at the top level
    if m.top.isTopOutlet then
        if key = "back" then
            return rokuRouter.goBack()
        end if
    end if

    return false
end function